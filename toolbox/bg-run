#!/usr/bin/env bash
# bg-run - Run a command in the background and return a task ID
# Toolbox tool for Amp - mimics Claude Code's run_in_background feature
# Auto-kills after timeout (default 2h) to prevent zombie processes

set -euo pipefail

TASKS_DIR="${TASKS_DIR:-${HOME}/.local/state/amp-bg-tasks}"

if [[ "${TOOLBOX_ACTION:-}" == "describe" ]]; then
    cat <<'SCHEMA'
{
  "name": "bg_run",
  "description": "Run a shell command in the background. Returns a task ID you can use with bg_status, bg_output, and bg_stop to monitor and manage the process. Tasks auto-kill after timeout (default 2 hours) to prevent zombie processes if the user closes Amp or forgets. Use timeout=0 to disable auto-kill for intentionally long-running tasks.",
  "inputSchema": {
    "type": "object",
    "properties": {
      "command": {
        "type": "string",
        "description": "The shell command to execute in the background"
      },
      "label": {
        "type": "string",
        "description": "Optional short label for this task (e.g. 'tests', 'dev-server')"
      },
      "cwd": {
        "type": "string",
        "description": "Optional working directory for the command. Defaults to current directory."
      },
      "timeout": {
        "type": "integer",
        "description": "Auto-kill after N minutes. Default: 120 (2 hours). Set 0 to disable. Prevents zombie processes if you close Amp or forget."
      }
    },
    "required": ["command"]
  }
}
SCHEMA
    exit 0
fi

# Execute mode
INPUT=$(cat)
COMMAND=$(echo "$INPUT" | jq -r '.command // empty')
LABEL=$(echo "$INPUT" | jq -r '.label // empty')
CWD=$(echo "$INPUT" | jq -r '.cwd // empty')
TIMEOUT=$(echo "$INPUT" | jq -r '.timeout // "120"')

if [[ -z "$COMMAND" ]]; then
    echo '{"error": "command is required"}'
    exit 1
fi

# Generate task ID
TASK_ID="task-$(date +%s)-$$"
TASK_DIR="${TASKS_DIR}/${TASK_ID}"
mkdir -p "$TASK_DIR"

# Store metadata
echo "$COMMAND" > "$TASK_DIR/command"
echo "${LABEL:-$TASK_ID}" > "$TASK_DIR/label"
date -u +"%Y-%m-%dT%H:%M:%SZ" > "$TASK_DIR/started_at"
echo "running" > "$TASK_DIR/status"
echo "$TIMEOUT" > "$TASK_DIR/timeout"

# Resolve working directory
WORK_DIR="${CWD:-$(pwd)}"
echo "$WORK_DIR" > "$TASK_DIR/cwd"

# Run command in background with output capture
(
    cd "$WORK_DIR" 2>/dev/null || true
    set +e
    bash -c "$COMMAND" > "$TASK_DIR/stdout" 2> "$TASK_DIR/stderr"
    EXIT_CODE=$?
    set -e
    echo "$EXIT_CODE" > "$TASK_DIR/exit_code"
    if [[ $EXIT_CODE -eq 0 ]]; then
        echo "completed" > "$TASK_DIR/status"
    else
        echo "failed" > "$TASK_DIR/status"
    fi
    date -u +"%Y-%m-%dT%H:%M:%SZ" > "$TASK_DIR/finished_at"
) </dev/null >/dev/null 2>/dev/null &

BG_PID=$!
echo "$BG_PID" > "$TASK_DIR/pid"

# Spawn watchdog to auto-kill after timeout
if [[ "$TIMEOUT" -gt 0 ]] 2>/dev/null; then
    TIMEOUT_SECS=$((TIMEOUT * 60))
    (
        sleep "$TIMEOUT_SECS" 2>/dev/null
        # Check if still running
        if kill -0 "$BG_PID" 2>/dev/null; then
            kill -- -"$BG_PID" 2>/dev/null || kill "$BG_PID" 2>/dev/null || true
            sleep 1
            kill -9 "$BG_PID" 2>/dev/null || true
            echo "timeout" > "$TASK_DIR/status"
            echo "143" > "$TASK_DIR/exit_code"
            date -u +"%Y-%m-%dT%H:%M:%SZ" > "$TASK_DIR/finished_at"
        fi
    ) </dev/null >/dev/null 2>/dev/null &
    WATCHDOG_PID=$!
    echo "$WATCHDOG_PID" > "$TASK_DIR/watchdog_pid"
    # Ensure watchdog dies if main process finishes early
    (
        while kill -0 "$BG_PID" 2>/dev/null; do sleep 5; done
        kill "$WATCHDOG_PID" 2>/dev/null || true
    ) </dev/null >/dev/null 2>/dev/null &
fi

# Build response
TIMEOUT_MSG=""
if [[ "$TIMEOUT" -gt 0 ]] 2>/dev/null; then
    TIMEOUT_MSG="Auto-kills in ${TIMEOUT}m."
else
    TIMEOUT_MSG="No auto-kill (timeout disabled)."
fi

jq -n \
    --arg id "$TASK_ID" \
    --arg pid "$BG_PID" \
    --arg command "$COMMAND" \
    --arg label "${LABEL:-$TASK_ID}" \
    --arg cwd "$WORK_DIR" \
    --arg timeout "$TIMEOUT" \
    --arg timeout_msg "$TIMEOUT_MSG" \
    '{
        task_id: $id,
        pid: ($pid | tonumber),
        command: $command,
        label: $label,
        cwd: $cwd,
        timeout_minutes: ($timeout | tonumber),
        status: "running",
        message: ("Task started in background. " + $timeout_msg + " Use bg_status or bg_output to check progress.")
    }'
